{"name":"Larastaller","tagline":"The Larastaller package provides a fluent interface via web or artisan to install/upgrade your project.","body":"## Larastaller Package\r\n[![Packagist License](https://poser.pugx.org/leemason/larastaller/license.png)](http://choosealicense.com/licenses/mit/)\r\n[![Latest Stable Version](https://poser.pugx.org/leemason/larastaller/version.png)](https://packagist.org/packages/leemason/larastaller)\r\n[![Total Downloads](https://poser.pugx.org/leemason/larastaller/d/total.png)](https://packagist.org/packages/leemason/larastaller)\r\n[![Build Status](https://travis-ci.org/leemason/larastaller.svg?branch=master)](https://travis-ci.org/leemason/larastaller)\r\n\r\nThe Larastaller package provides a fluent interface via web or artisan to install/upgrade your project.\r\n\r\n## Installation\r\n\r\nRequire this package with composer:\r\n\r\n```\r\ncomposer require leemason/larastaller\r\n```\r\n\r\nAfter updating composer, add the ServiceProvider to the providers array in config/app.php\r\n\r\n## Laravel 5.1:\r\n\r\n```php\r\nLeeMason\\Larastaller\\LarastallerServiceProvider::class,\r\n```\r\n\r\nCopy the packages config to your config folder with the publish command:\r\n\r\n```php\r\nphp artisan vendor:publish --force\r\n```\r\n\r\nOnce completed you should now have a config file located at config/larastaller.php.\r\n\r\nIn this file you will see 2 array items, ```requirements``` and ```versions```.\r\n\r\nBoth are arrays, requirements will contain some basic laravel required items to get you started (you may not need any more).\r\n\r\nBut for versions you will need to add your own. Each version can have the following:\r\n\r\n```php\r\n'1.0.0' => [\r\n    'changes' => [\r\n        'this is a change',\r\n        'this is another'\r\n    ],\r\n    'requirements' => [\r\n        //.. the same as the main requirements\r\n    ],\r\n    'tasks' => [\r\n        \\LeeMason\\Larastaller\\Tasks\\AppKeyTask::class,\r\n        \\LeeMason\\Larastaller\\Tasks\\MigrateTask::class,\r\n        //.. any more tasks you need to complete for this version\r\n    ],\r\n]\r\n```\r\n\r\nAs you can see the array key is the version string. This must be formatted in a way compatible with the php ```version_compare``` function.\r\n\r\n## Compatability\r\n\r\nThe Larastaller package has been developed with Laravel 5.1, i see no reason why it wouldn't work with 5.0 or even 4 but it is only tested for 5.1.\r\n\r\n## Introduction\r\n\r\n@todo\r\n\r\n## Usage\r\n\r\n### http\r\n\r\n@todo\r\n\r\n### artisan\r\n\r\nThe larastaller package comes with multiple installer commands which are listed below:\r\n\r\n```\r\nphp artisan installer:install\r\n```\r\n\r\nThis will:\r\n\r\n- Run through requirements for all versions, test them and report any errors.\r\n- Request via console questions, passwords, choices and true/false fields all of the data requested by each task\r\n- Resolve each task class and perform the tasks ```handle()``` function\r\n- If a task throws and exception, the install will cease\r\n- If all tasks complete successfully save the installation details into the ```storage_path('installation.json');``` file\r\n- Report the install as a success and exit\r\n\r\n```\r\nphp artisan installer:changes $version\r\n```\r\n\r\n```$version```` Possible values [\"latest\", \"last-x\" eg (last-5), \"version\" string eg (1.1.1), \"all\"]\r\n\r\nThis will fetch the version(s) requested and display the changes added to the version array as a list.\r\n\r\n\r\n## Configuration\r\n\r\nIncluded with the package is a config/larastaller.php file where the base config is loaded from, with an empty versions array.\r\n\r\nThis (after following the install steps above) gets copied to your applications config folder and should contain all of your custom requirements and versions.\r\n\r\nThe first key in the array is the list of requirements for installation (independent of any version).\r\n\r\nIncluded with the package are some requirement classes which provide requirements that must be fulfilled for any laravel application, but if you have other requirements specific to your app you should append them here.\r\n\r\n```php\r\n'requirements' => [\r\n    \\LeeMason\\Larastaller\\Requirements\\PhpVersionRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\PdoRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\MbStringRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\OpenSSLRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\TokenizerRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\FolderPermissionsRequirement::class,\r\n    \\LeeMason\\Larastaller\\Requirements\\EnvFileRequirement::class,\r\n],\r\n```\r\n\r\nThe second item is the versions array, this contains an array of versions for the application.\r\n\r\nEach version should be added as an index in the array with the version details as the keys value.\r\n\r\n```php\r\n'versions' => [\r\n    '1.0.0' => [\r\n        'changes' => [\r\n            'this is a change'\r\n        ],\r\n        'requirements' => [\r\n\r\n        ],\r\n        'tasks' => [\r\n            \\LeeMason\\Larastaller\\Tasks\\AppKeyTask::class,\r\n            \\LeeMason\\Larastaller\\Tasks\\MigrateTask::class,\r\n        ],\r\n    ],\r\n    '1.0.1' => [\r\n        //..\r\n    ],\r\n],\r\n```\r\n\r\nEach version should contain an array of changes, and array of requirements (useful if server requirements change per version), and a tasks array.\r\n\r\n## The Definition Class\r\n\r\nThe ```LeeMason\\Larastaller\\Definition class is quite simply a data storage object which allows more fluent access to the configuration, and news up ```LeeMason\\Laratsaller\\Version``` instances for each version.\r\n\r\nIt has a public api, but is designed soley for insternal usage via the Larastaller package.\r\n\r\n\r\n## Requirement Classes\r\n\r\nRequirement Classes are used to test the environment is suitable for the application to be installed.\r\n\r\nThey must implement the ```LeeMason\\Larastaller\\RequirementInterface``` and ideally extends the abstract ```LeeMason\\Larastaller\\Requirement``` class.\r\n\r\nEach requirement class should contain the public properties ```$description```, ```$success```, ```$error``` with descriptive strings explain the requirement and providing user friendly messages.\r\n\r\nA requirement class can optionally include a ```__construct()``` method to inject any dependencies via the ServiceContainer and these will automatically be resolved.\r\n\r\nThe last and most important method a requirement class **MUST** provide is a ```test()``` method which should return a boolean true/false depending on if the requirement has been fulfilled.\r\n\r\nMost requirements just test the existence of the requirement, but the ```EnvFileRequirement``` is a special case as this will automatically copy the .env.example to .env if no .env file is present before testing.\r\n\r\nThis was chosen over making it a task simply because of a laravel application lifecycle.\r\n\r\n\r\n## Task Classes\r\n\r\nTask Classes are used to perform the tasks needed to install the application.\r\n\r\nThey must implement the ```LeeMason\\Larastaller\\TaskInterface``` and ideally extends the abstract ```LeeMason\\Larastaller\\Task``` class.\r\n\r\nEach task class should contain the public property ```$title``` with a descriptive string explaining the tasks function.\r\n\r\nA task class can optionally include a ```__construct()``` method to inject any dependencies via the ServiceContainer and these will automatically be resolved.\r\n\r\nFor the task to actually perform anything it should include a ```handle()``` method.\r\n\r\nThis method can do anything from running artisan commands, to altering database tables.\r\n\r\nIf the task should provide any user feedback messages during execution it can do so by using its ```$this->output``` property which will always be in stance of ```Symfony\\Component\\Console\\Output\\OutputInterface```.\r\n\r\nThis allows the task to add output by using the ```$this->output->writeLn('...');``` method.\r\n\r\nIncluded with the package are some basic tasks to get you started:\r\n\r\n```\r\nLeeMason\\Larastaller\\Tasks\\AppKeyTask\r\n```\r\n\r\nThis task is very simple and performs the ``` php artisan key:generate``` command, returning its output.\r\n\r\nWe suggest this task be the first task registered for the first version you include.\r\n\r\n\r\n\r\n```\r\nLeeMason\\Larastaller\\Tasks\\MigrateTask\r\n```\r\n\r\nThis task on its own will simply perform the same function as calling ``` php artisan migrate```, so it is a useful task that can be added to any version which adds migrations to your application.\r\n\r\nHowever its also been designed specifically with extendability in mind.\r\n\r\nFor example if you need to migrate a package, or provide options to the migrate command, you can extend the class and add your parameters to the ```$parameters``` array.\r\n\r\n```php\r\nuse LeeMason\\Larastaller\\Tasks\\MigrateTask;\r\n\r\nclass MigratePackageTask extends MigrateTask{\r\n\r\n    protected $parameters = [\r\n        '--path' => 'vendor/name/package/migrations'\r\n    ];\r\n\r\n}\r\n```\r\n\r\nThis will run: ``` php artisan migrate --path=vendor/name/package/migrations```\r\n\r\n\r\n## The Installation Class\r\n\r\nThe ```LeeMason\\Larastaller\\Installation``` class is a class responsible for fetching and updating the applications ```storage_path('installation.json')``` file.\r\n\r\nIt extends the ```Illuminate\\Support\\Collection``` class and all items from the ```storage_path('installation.json')``` file are stored as key > value items.\r\n\r\nThis class can provide and save data about the installation and it used by the ```LeeMason\\Larastaller\\Installer``` class for checking if the appliction is installed, and if it is up to date.\r\n\r\nIt is registered in the service container so can be injected and provides the public methods: ```$installation->isInstalled()```, ```$installation->isUpdated()``` on top of the Collection classes methods.\r\n\r\nIf you need to persist changes or additions to the installation.json file always make sure you call the ```$installation->save()``` method.\r\n\r\n\r\n## The Installer Class\r\n\r\nThe ```LeeMason\\Larastaller\\Installer``` class is responsible for matching installed version against versions declared and generally formatting the configuration of tasks, requirements, etc fo use via the http and command based install methods.\r\n\r\nIt provides no public api usable outside of its duties.\r\n\r\n\r\n## FAQ\r\n\r\n**Why not just use version control?**\r\n\r\nVersion control is great, and the way we have designed the configuration for the package to best use the features of version control.\r\n\r\nBut services like git/svn etc can't for example:\r\n\r\n- Clear caches on updates\r\n- Modify database data between versions\r\n- Alert to the need of new env vars\r\n- etc\r\n\r\nSure each one of the those can be done manually, or even via multiple artisan commands, but the user needs to know those changes are needed.\r\n\r\nWith the larastaller config saved in version control anyone who needs to install it can just run ```installer:install``` without a task list in front of them.\r\n\r\n**Does this replace the need for composer?**\r\n\r\nNo it doesn't and we wouldn't want to either.\r\n\r\nWhat it does mean is you can distribute your application with one simple step.\r\n\r\nSimply add ```\"php artisan installer:install\"``` to your composer.json files ```\"post-install-command\"``` array.\r\n\r\nThen the install proccess will happen after ```composer install```.\r\n\r\n** If you would prefer to use the web api simply distribute your application with the vendor directory propigated and direct them to the install url.\r\n\r\n\r\n## Notes\r\n\r\nIts still in early development, functionality yet to be included is:\r\n\r\nWeb api for installing\r\nUpdating existing installs\r\n\r\n\r\n## The Future\r\n\r\n- Add web api/route\r\n- Add installer:update command\r\n- Minor functionality improvements","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}